---

title: "Foundations First, Fluency Follows"
description: "What happens when we skip the hard parts? As AI reshapes software development, junior engineers need more than shortcuts—they need the struggle and structure that builds real understanding."
pubDatetime: 2025-07-29T12:00:00.000Z
modDatetime: null
author: Jeremy Cyr
featured: true
draft: false
tags:
  - software-development
  - ai-tooling
  - mentorship
  - learning
  - engineering-culture
canonicalURL: ""

---
I always wanted to play the piano, though I never liked the idea of lessons. Why spend months repeating ultra-simple pieces when I could just sit down and, by ear, learn something fun and impressive?

For a while, that’s exactly what I did—I'd listen to a piece, work it out note by note, and play it through until it sounded right. It worked well enough. I could play things that sounded advanced. But I wasn’t actually getting better.

Every time I tried to learn something more complex, I hit a wall. No matter how many times I practiced, I couldn’t get it right. My hands wouldn’t cooperate.

I was missing the foundational skills: the muscle memory, the posture, the theory. Scales and arpeggios. Rhythms and dynamics. Transitions and phrasing. All the things piano lessons were designed to teach—refined over centuries with purpose and structure.

Piano teachers roll their eyes when you skip the basics—and with good reason. The method works. Go rogue, and you’ll hit a wall that often requires unlearning bad habits before making real progress.

The experience taught me something I now see playing out in the software engineering space. Developers today face a similar temptation: to skip the slow, frustrating parts in favor of instant feedback and quick results.

## The Irresistable Call of AI Tooling

There's no doubt that the AI tools available today are doing things we couldn't have imagined a few years ago.  Scaffolding projects, answering questions, developing against complex patterns, writing tests, debugging.  In the hands of someone experienced these tools can increase the velocity of development many times over.  But as we build up the next generation of experienced engineers with access to these tools, how are they learning those ever important fundamentals if we've delegated away the execution?

**The pipeline that once slowly shaped problem-solvers through repetition and refinement now risks producing operators of tools—not architects of systems.**

## What We're Losing

Instead of learning through the pain of debugging, a junior dev can now get answers instantly—often without fully understanding the question.
They can ship code that works, but can they explain why it works? Can they reason about trade-offs, scalability, failure modes?

You might see code that’s either dangerously naive or needlessly complex—full of overlapping abstractions that don’t serve a clear purpose. And when you ask the developer why they chose that approach, it’s clear they never really made a choice.

These gaps don’t stay hidden for long. In time, they show up in how projects unfold, how reviews stagnate, and how confidence quietly erodes.

You may start to see a few common signs:

* Projects that stall when AI can no longer keep up with the context, and the developer can't rescue it.
* Code Reviews where the developer can't explain what the code is *actually* doing.
* Unnecessary complexity or over-simplicity


## Reintroducing Friction

Start with the fundamentals. Twinkle-twinkle before La Campanella. Make sure early-career engineers build *without* the advanced tools before they build *with* them. Give them problems to struggle through, to reason about, to debug by hand. 

Introduce AI gradually, with guardrails
* Start with basic Q&A models and simple autocomplete.
* Progress to cut-and-paste tools that require manual context management.
* Then bring in IDE-integrated assistants with shallow reasoning.
* Finally, graduate to full agentic systems with deep, context-aware support.

Require justification. Ask why they chose that solution. What would happen if the assumptions broke? What are the failure modes?

Normalize failure as an important part of the process.

Model curiosity. Have seniors narrate their decision-making out loud. Show not just what they did, but *why* they didn’t do the ten other things that looked reasonable on the surface.

Build governance that turns failure into a feedback loop. Code reviews aren’t just about bugs—they’re about transferring judgment.

As engineering leaders, we need to mimic the role of the piano teacher, providing structure, pushing the importance of fundamentals.  

Beyond that, we need to assure that our processes are adequately equipped to evaluate the aspects of the delivered code that go beyond the feature delivery: scalability, readability, complexity, failure modes, test coverage.  These are all things that require careful reasoning and understanding, that while they can be assisted by tooling, need to be carefully considered and guided, and require that foundational set of skills with which to evaluate and action.

## Foundations First, Fluency Follows

“Slow down! The speed will come,” my piano teacher would often say when I rushed ahead of what my skill—or my practice—could support.

Like music, software has structure. And just like a pianist can’t fake their way through a complex passage without foundational technique, a developer can’t reason well about systems they never learned to construct. They can’t explain why something works, how to fix it when it breaks, or when not to build it at all.

As teams, we can’t just hand over the sheet music and hope for the best. We have to create an environment where foundational learning is expected—and supported. That means giving space for struggle, not always rushing to unblock. It means asking questions that require judgment, not just output. It means designing code reviews that teach, not just approve.

If we want to grow engineers who can design, adapt, and lead—not just copy, paste, and prompt—we need to give them room to learn the scales. To make mistakes. To understand the why beneath the what.