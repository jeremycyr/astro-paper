---

title: "Foundations First, Fluency Follows"
description: "What happens when we skip the hard parts? As AI reshapes software development, junior engineers need more than shortcuts—they need the struggle and structure that builds real understanding."
pubDatetime: 2025-07-29T12:00:00.000Z
modDatetime: null
author: Jeremy Cyr
featured: true
draft: false
tags:
  - software-development
  - ai-tooling
  - mentorship
  - learning
  - engineering-culture
canonicalURL: ""

---
I always wanted to play the piano, though I never liked the idea of lessons. Why spend months repeating ultra-simple pieces when I could just sit down and, by ear, learn something fun and impressive?

For a while, that’s exactly what I did—I'd listen to a piece, work it out note by note, and play it through until it sounded right. It worked well enough. I could play things that sounded advanced. But I wasn’t actually getting better.

Every time I tried to learn something more complex, I hit a wall. No matter how many times I practiced, I couldn’t get it right. My hands wouldn’t cooperate.

I was missing the foundational skills: the muscle memory, the posture, the theory. Scales and arpeggios. Rhythms and dynamics. Transitions and phrasing. All the things piano lessons were designed to teach—refined over centuries with purpose and structure.

Piano teachers roll their eyes when you skip the basics—and with good reason. The method works. Go rogue, and you'll hit a wall that often requires unlearning bad habits before making real progress.

The experience taught me something I now see playing out in the software engineering space. Developers today face a similar temptation: to skip the slow, frustrating parts in favor of instant feedback and quick results.

## The Irresistable Call of AI Tooling

There's no doubt that the AI tools available today are doing things we couldn't have imagined a few years ago.  Scaffolding projects, answering questions, developing against complex patterns, writing tests, debugging.  In the hands of someone experienced these tools can increase the velocity of development many times over.  But as we build up the next generation of experienced engineers with access to these tools, how are they learning those ever important fundamentals if we've delegated away the execution?

The pipeline that once slowly shaped problem-solvers through repetition and refinement now risks producing operators of tools—not architects of systems.

## What We're Losing

Instead of learning through the grind of debugging and iteration, junior developers can now get answers instantly—often without fully grasping the question.

They can ship code that works, but can they explain why it works? Can they reason through edge cases, scalability, or failure modes? When things break, do they know how to trace the fault—or do they wait for a better prompt?

You start to see the symptoms:

Projects stall when AI can’t follow the shifting context—and the developer can’t fill the gap.
Code reviews where contributors can’t explain what their code actually does.
Systems that are either dangerously naive or bloated with abstractions that serve no real purpose.
These aren't just individual shortcomings—they're structural cracks. They compound quietly and show up later in design flaws, brittle systems, and teams that hesitate when judgment is required.

## Reintroducing Friction

Foundational learning isn't a luxury—it's a prerequisite.

Twinkle-twinkle before La Campanella. Before handing over high-powered tools, make sure early-career developers have built things the hard way. Let them wrestle with error messages, trace bugs by hand, write code from scratch.

Layer AI in deliberately:

Start with basic autocomplete and Q&A tools.
Advance to cut-and-paste snippets that require understanding and adaptation.
Move to integrated assistants that offer suggestions—but still require human steering.
Graduate to agentic systems only once foundational judgment is already in place.
Require justification. Ask: Why this approach? What trade-offs did you consider? What breaks if your assumptions are wrong?

Normalize struggle. Model curiosity. Let seniors narrate their thinking—especially the paths they didn’t take.

Code reviews shouldn't just catch bugs; they should build judgment. Processes should evaluate not just the delivered feature, but its durability: clarity, complexity, failure handling, test coverage. These aren’t boxes to check—they’re signs of engineering maturity.

As leaders, we need to be the piano teachers. Push for structure. Demand fundamentals. And above all, create an environment where learning through friction isn’t an exception—it’s the norm.

## Foundations First, Fluency Follows

"Slow down! The speed will come," my piano teacher would often say when I rushed ahead of what my skill—or my practice—could support.

Like music, software has structure. And just like a pianist can't fake their way through a complex passage without foundational technique, a developer can't reason well about systems they never learned to construct. They can't explain why something works, how to fix it when it breaks, or when not to build it at all.

As teams, we can’t just hand over the sheet music and hope for the best. We have to create an environment where foundational learning is expected—and supported. That means giving space for struggle, not always rushing to unblock. It means asking questions that require judgment, not just output. It means designing code reviews that teach, not just approve.

If we want to grow engineers who can design, adapt, and lead—not just copy, paste, and prompt—we need to give them room to learn the scales. To make mistakes. To understand the why beneath the what.